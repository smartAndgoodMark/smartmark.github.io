(window.webpackJsonp=window.webpackJsonp||[]).push([[13],{511:function(v,_,t){v.exports=t.p+"assets/img/leetcode1.acf8aeae.png"},535:function(v,_,t){"use strict";t.r(_);var e=t(1),a=Object(e.a)({},(function(){var v=this,_=v.$createElement,e=v._self._c||_;return e("ContentSlotsDistributor",{attrs:{"slot-key":v.$parent.slotKey}},[e("div",{staticClass:"custom-block tip"},[e("p",[v._v("陆陆续续刷了400题, 但是打周末赛分数一直没有进一步提高, 可能进入了一个别人说的瓶颈期?")]),v._v(" "),e("p",[v._v("自己比较懒散, 没能养成记笔记, 多总结的习惯, 趁比赛前总结下.")])]),v._v(" "),e("h2",{attrs:{id:"灵魂问题"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#灵魂问题"}},[v._v("#")]),v._v(" 灵魂问题")]),v._v(" "),e("ol",[e("li",[e("p",[v._v("leetcode上的题目到底是什么?")]),v._v(" "),e("ul",[e("li",[v._v("需要一定编程技巧的面试编程题")]),v._v(" "),e("li",[v._v("需要了解一些数据结构和常见算法")]),v._v(" "),e("li",[v._v("题量非常大, 每个题想过, 都需要一定的时间(时间管理大师才能快速完成吧)")]),v._v(" "),e("li",[v._v("可以让我认识到自己是个弱鸡")]),v._v(" "),e("li",[v._v("....")])])])]),v._v(" "),e("h2",{attrs:{id:"怎么一起分析这么多题目呢"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#怎么一起分析这么多题目呢"}},[v._v("#")]),v._v(" 怎么一起分析这么多题目呢")]),v._v(" "),e("p",[v._v("先通过"),e("a",{attrs:{href:"https://github.com/Liuyang0001/Leetcode-Helper",target:"_blank",rel:"noopener noreferrer"}},[v._v("Leetcode-Helper项目"),e("OutboundLink")],1),v._v("把刷过的题目代码记录获取")]),v._v(" "),e("p",[e("code",[v._v("leetcode")]),v._v(" 上本身有一些简单的分析\n"),e("img",{attrs:{src:t(511),alt:"图片"}}),v._v("\n但是想要分析全面一点, 从记录中寻找")]),v._v(" "),e("h2",{attrs:{id:"题型分类"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#题型分类"}},[v._v("#")]),v._v(" 题型分类")]),v._v(" "),e("p",[v._v("其实"),e("code",[v._v("leetcode")]),v._v("每一道题目都有标签, 我们写代码看看都做了哪些分类\n晚点抽点时间改下代码, 当前写的话,可能来不及了")]),v._v(" "),e("h2",{attrs:{id:"错误分类"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#错误分类"}},[v._v("#")]),v._v(" 错误分类")]),v._v(" "),e("ol",[e("li",[e("p",[v._v("审题不清")]),v._v(" "),e("p",[v._v("问题:在对题目和例子没有完全弄清楚,就开始写代码, 造成错误")]),v._v(" "),e("p",[v._v("应对办法: 逐字阅读题目, 样例和数字条件等, 写代码前确认自己的方法, 可以完成题目的需求, 能过例子等")])]),v._v(" "),e("li",[e("p",[v._v("特殊例子")]),v._v(" "),e("p",[v._v("问题: 没有考虑问题附带的边界条件, 编码片段出现的边界条件等\n应对办法: 预先考虑特殊情况, 并做测试, 确定边界是否处理妥当")])]),v._v(" "),e("li",[e("p",[v._v("题目有一定难度")]),v._v(" "),e("p",[v._v("问题: 没能完全分析出来, 先试可能的解法, 看能否解决")]),v._v(" "),e("p",[v._v("应对办法: 建议放弃, 直接看提示, 或者再发散思维看能否想明白. 通常猜一个方法写完,通过的概率很小, 不妨多想一下, 没必要在情况不明的情况下写代码. 毕竟有很多题目还没做明白!理智一点, 保持良好心态!")])]),v._v(" "),e("li",[e("p",[v._v("超时\n问题: 通常是方法复杂度过高, 或者出现死循环")]),v._v(" "),e("p",[v._v("应对方法: 尽可能选择最优方法实现, 判断问题的复杂度, 看是否o(m)*问题数量级<10**6; 死循环, 少用while, 尽量for, 如果用while, 关注什么情况下不会出现return或者break")]),v._v(" "),e("p",[v._v("tip")]),v._v(" "),e("p",[v._v("如果是数组问题, 想想哈希表, 二分,  动态规划, 双指针, 前缀编码等能否优化")]),v._v(" "),e("p",[v._v("如果是回溯等遍历, 看是否能通过堆, 贪心, 排序, 等数据结构或者方法优化")]),v._v(" "),e("p",[v._v("如果是动态规划, 看递推式是否最优, 另外考虑是否有更优的解法, 低于当前动态规划复杂的解法, 记忆化递归 有可能通过,")])]),v._v(" "),e("li",[e("p",[v._v("超出内存限制\n确定不是自己的输出问题, 另外代码使用的数据结构是否变量使用不合理, 通常代码的时间复杂度可能也过高")])]),v._v(" "),e("li",[e("p",[v._v("待续")])])]),v._v(" "),e("h2",{attrs:{id:"程序分析"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#程序分析"}},[v._v("#")]),v._v(" 程序分析")]),v._v(" "),e("h2",{attrs:{id:"竞赛-虚拟-竞赛分析"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#竞赛-虚拟-竞赛分析"}},[v._v("#")]),v._v(" 竞赛(虚拟)竞赛分析")]),v._v(" "),e("ol",[e("li",[v._v("限时,可以模拟面试的情况, 毕竟面试官不可能一直等你做完")]),v._v(" "),e("li",[v._v("可以获知排名, 大致知道自己与高手之间的差距, 同时获知题目最快的解题时间")]),v._v(" "),e("li",[v._v("结束后可能很快获取答案, 适合快速刷题")]),v._v(" "),e("li")]),v._v(" "),e("h2",{attrs:{id:"总结"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#总结"}},[v._v("#")]),v._v(" 总结")]),v._v(" "),e("ol",[e("li",[v._v("我好菜, 但是我会继续努力 的")]),v._v(" "),e("li",[v._v("https://oi-wiki.org/, 这个网站很不一般, 总结了很多知识点 是下一步主要研究分析的资料")])]),v._v(" "),e("h2",{attrs:{id:"开放问题"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#开放问题"}},[v._v("#")]),v._v(" 开放问题")]),v._v(" "),e("p",[v._v("1.有没有可能找到一种最优的刷题路线")]),v._v(" "),e("p",[v._v("题目涉及的知识和算法是一定的, 那是不是只要会做一部分题目就可以刷完所有的知识点呢")]),v._v(" "),e("p",[v._v("这里最优可以是, 平均难度最小, 也可以是错误率最小, 也可以是平均耗时最小, 当然也可以是它们一起的最小")]),v._v(" "),e("p",[v._v("因为我们可以思考下, 假定每个不同的题目在特定的测试样例下, 最优解法只有一种(不考虑语言不同, 或在同一语言下比较)")]),v._v(" "),e("p",[v._v("那我们再进一步假设, 每个不同的题目看成是不同知识组合产生的一种拓扑结构, 进而, 如果能找到一种覆盖所有知识的最小题目组合,是不是就能获得一个最优刷题路线")]),v._v(" "),e("p",[v._v("这样的最小覆盖一定存在, 每一个都是不可替代的,则会是全集")]),v._v(" "),e("p",[v._v("未完待续...")])])}),[],!1,null,null,null);_.default=a.exports}}]);